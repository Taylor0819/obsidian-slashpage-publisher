/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SlashpagePublisherPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  defaultDomainName: "",
  defaultChannelHash: "",
  defaultTokenKey: "",
  folderMappings: []
};
var SlashpagePublisherPlugin = class extends import_obsidian.Plugin {
  /**
   * 플러그인이 로드될 때 호출됩니다
   */
  async onload() {
    await this.loadSettings();
    this.registerUIElements();
    this.registerCommands();
    this.addSettingTab(new SlashpagePublisherSettingTab(this.app, this));
  }
  /**
   * UI 요소를 등록합니다 (리본 아이콘 등)
   */
  registerUIElements() {
    this.addRibbonIcon("paper-plane", "Publish to Slashpage", (evt) => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (activeView) {
        this.publishToSlashpage(activeView);
      } else {
        new import_obsidian.Notice("Please open a markdown file to publish.");
      }
    });
  }
  /**
   * 명령어를 등록합니다
   */
  registerCommands() {
    this.addCommand({
      id: "publish-to-slashpage",
      name: "Publish to Slashpage",
      editorCallback: (editor, view) => {
        this.publishToSlashpage(view);
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  /**
   * 현재 파일의 내용과 제목을 가져옵니다
   */
  getCurrentFileContent(view) {
    if (!view.file) {
      new import_obsidian.Notice("\uC5F4\uB9B0 \uD30C\uC77C\uC744 \uCC3E\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
      return null;
    }
    const title = view.file.basename;
    const content = view.editor.getValue();
    return { title, content };
  }
  /**
   * 파일 경로에 따른 적절한 채널 설정을 찾습니다
   */
  findChannelSettings(filePath) {
    const fileFolder = filePath.substring(0, filePath.lastIndexOf("/"));
    let domainName = this.settings.defaultDomainName;
    let channelHash = this.settings.defaultChannelHash;
    let tokenKey = this.settings.defaultTokenKey;
    let longestMatch = -1;
    for (const mapping of this.settings.folderMappings) {
      if (fileFolder.startsWith(mapping.folderPath) && mapping.folderPath.length > longestMatch) {
        longestMatch = mapping.folderPath.length;
        domainName = mapping.domainName;
        channelHash = mapping.channelHash;
        tokenKey = mapping.tokenKey;
      }
    }
    if (!domainName || !channelHash || !tokenKey) {
      new import_obsidian.Notice("Please complete Slashpage settings first.");
      return null;
    }
    return { domainName, channelHash, tokenKey };
  }
  /**
   * Slashpage API를 호출하여 노트를 발행합니다
   */
  async callSlashpageAPI(domainName, channelHash, tokenKey, title, content) {
    try {
      const apiUrl = `https://slashpage.com/api-webhook/note/${domainName}/${channelHash}/${tokenKey}`;
      console.log("CORS \uC81C\uD55C\uC73C\uB85C \uC778\uD574 \uC9C1\uC811 API \uD638\uCD9C \uB300\uC2E0 \uB300\uC548 \uBC29\uC2DD\uC744 \uC81C\uACF5\uD569\uB2C8\uB2E4.");
      const requestBody = JSON.stringify({
        title,
        body: content
      }, null, 2);
      const curlCommand = `curl -X POST -H "Content-Type: application/json" \\
  --data-raw '${requestBody.replace(/'/g, "\\'")}' \\
  ${apiUrl}`;
      console.log("Slashpage API URL:", apiUrl);
      console.log("\uBC1C\uD589\uD560 \uB178\uD2B8 \uC81C\uBAA9:", title);
      console.log("\uBCF8\uBB38 \uAE38\uC774:", content.length);
      console.log("===== \uB514\uBC84\uAE45 \uC815\uBCF4 \uC2DC\uC791 =====");
      const debugHeaders = {
        "Content-Type": "application/json",
        "User-Agent": "ObsidianSlashpagePublisher/1.0",
        "Accept": "*/*",
        "Origin": "app://obsidian.md",
        "Referer": "app://obsidian.md/"
      };
      const actualHeaders = new Headers(debugHeaders);
      const actualHeadersObj = {};
      console.log("\uC2E4\uC81C \uC694\uCCAD \uD5E4\uB354 \uC815\uBCF4:");
      actualHeaders.forEach((value, key) => {
        actualHeadersObj[key] = value;
        console.log(`- ${key}: ${value}`);
      });
      console.log("\uC2E4\uC81C \uC694\uCCAD \uD5E4\uB354(JSON):", JSON.stringify(actualHeadersObj, null, 2));
      const testRequest = new Request(apiUrl, {
        method: "POST",
        headers: debugHeaders,
        body: requestBody,
        mode: "cors"
      });
      console.log("Request \uC694\uCCAD URL:", testRequest.url);
      console.log("Request \uC694\uCCAD \uBA54\uC11C\uB4DC:", testRequest.method);
      console.log("\uC694\uCCAD \uBCF8\uBB38 \uC0D8\uD50C (\uCC98\uC74C 200\uC790):", requestBody.substring(0, 200) + (requestBody.length > 200 ? "..." : ""));
      try {
        console.log("requestUrl \uD568\uC218\uB97C \uC0AC\uC6A9\uD55C \uC694\uCCAD \uC2DC\uB3C4...");
        const testResponse = await (0, import_obsidian.requestUrl)({
          url: apiUrl,
          method: "POST",
          headers: debugHeaders,
          body: requestBody
        });
        console.log("\uC751\uB2F5 \uC0C1\uD0DC:", testResponse.status);
        console.log("\uC751\uB2F5 \uD5E4\uB354:", testResponse.headers);
        console.log("\uC751\uB2F5 \uBCF8\uBB38:", testResponse.text);
        new import_obsidian.Notice(`Slashpage\uC5D0 \uB178\uD2B8\uAC00 \uC131\uACF5\uC801\uC73C\uB85C \uBC1C\uD589\uB418\uC5C8\uC2B5\uB2C8\uB2E4!

\uBC1C\uD589\uB41C \uB178\uD2B8 \uD655\uC778\uD558\uAE30:
https://slashpage.com/${domainName}/`);
        return true;
      } catch (debugError) {
        console.log("\uC694\uCCAD \uC624\uB958 \uBC1C\uC0DD:", debugError);
        console.log("\uC694\uCCAD \uC815\uBCF4\uB294 \uCF58\uC194\uC5D0\uC11C \uD655\uC778 \uAC00\uB2A5\uD569\uB2C8\uB2E4.");
        await navigator.clipboard.writeText(curlCommand).catch((err) => {
          console.error("\uD074\uB9BD\uBCF4\uB4DC \uBCF5\uC0AC \uC2E4\uD328:", err);
        });
        new import_obsidian.Notice(`Slashpage API \uC694\uCCAD \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4.

curl \uBA85\uB839\uC5B4\uAC00 \uD074\uB9BD\uBCF4\uB4DC\uC5D0 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4.
\uD130\uBBF8\uB110\uC5D0 \uBD99\uC5EC\uB123\uC5B4 \uC2E4\uD589\uD558\uC138\uC694.

\uB610\uB294 \uB2E4\uC74C URL\uC5D0\uC11C \uBC1C\uD589\uB41C \uB178\uD2B8\uB97C \uD655\uC778\uD558\uC138\uC694:
https://slashpage.com/${domainName}/`, 15e3);
      }
      console.log("===== \uB514\uBC84\uAE45 \uC815\uBCF4 \uB05D =====");
      return true;
    } catch (error) {
      console.error("Slashpage \uBC1C\uD589 \uC900\uBE44 \uC624\uB958:", error);
      new import_obsidian.Notice("Slashpage \uBC1C\uD589 \uC900\uBE44 \uC911 \uC624\uB958\uAC00 \uBC1C\uC0DD\uD588\uC2B5\uB2C8\uB2E4. \uC790\uC138\uD55C \uB0B4\uC6A9\uC740 \uCF58\uC194\uC744 \uD655\uC778\uD574\uC8FC\uC138\uC694.");
      return false;
    }
  }
  /**
   * 현재 열린 노트를 Slashpage에 발행합니다
   */
  async publishToSlashpage(view) {
    const fileContent = this.getCurrentFileContent(view);
    if (!fileContent) return;
    const channelSettings = this.findChannelSettings(view.file.path);
    if (!channelSettings) return;
    await this.callSlashpageAPI(
      channelSettings.domainName,
      channelSettings.channelHash,
      channelSettings.tokenKey,
      fileContent.title,
      fileContent.content
    );
  }
};
var SlashpagePublisherSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Slashpage Publisher Settings" });
    this.addDefaultSettingsSection(containerEl);
    this.addFolderMappingsSection(containerEl);
  }
  /**
   * 기본 설정 섹션을 추가합니다
   */
  addDefaultSettingsSection(containerEl) {
    containerEl.createEl("h3", { text: "Default Settings" });
    containerEl.createEl("p", { text: "These settings will be used when no folder-specific settings are found." });
    this.addTextSetting(
      containerEl,
      "Default Domain Name",
      "Enter your Slashpage domain name",
      "my-domain",
      this.plugin.settings.defaultDomainName,
      async (value) => {
        this.plugin.settings.defaultDomainName = value;
        await this.plugin.saveSettings();
      }
    );
    this.addTextSetting(
      containerEl,
      "Default Channel Hash",
      "Enter your Slashpage channel hash",
      "channel-hash",
      this.plugin.settings.defaultChannelHash,
      async (value) => {
        this.plugin.settings.defaultChannelHash = value;
        await this.plugin.saveSettings();
      }
    );
    this.addTextSetting(
      containerEl,
      "Default Token Key",
      "Enter your Slashpage webhook token key",
      "your-token-key",
      this.plugin.settings.defaultTokenKey,
      async (value) => {
        this.plugin.settings.defaultTokenKey = value;
        await this.plugin.saveSettings();
      },
      true
      // 비밀번호 형식으로 표시
    );
  }
  /**
   * 폴더별 채널 설정 섹션을 추가합니다
   */
  addFolderMappingsSection(containerEl) {
    containerEl.createEl("h3", { text: "Folder-specific Channel Settings" });
    containerEl.createEl("p", { text: "Configure specific folders to publish to different channels." });
    this.folderMapContainer = containerEl.createDiv("folder-mapping-container");
    this.displayFolderMappings();
    new import_obsidian.Setting(containerEl).addButton((button) => button.setButtonText("Add Folder Mapping").setCta().onClick(() => {
      this.addNewFolderMapping();
    }));
  }
  /**
   * 새 폴더 매핑을 추가합니다
   */
  addNewFolderMapping() {
    this.plugin.settings.folderMappings.push({
      folderPath: "",
      domainName: this.plugin.settings.defaultDomainName,
      channelHash: this.plugin.settings.defaultChannelHash,
      tokenKey: this.plugin.settings.defaultTokenKey
    });
    this.plugin.saveSettings();
    this.displayFolderMappings();
  }
  /**
   * 텍스트 설정 필드를 추가합니다
   */
  addTextSetting(containerEl, name, desc, placeholder, value, onChange, isPassword = false) {
    const setting = new import_obsidian.Setting(containerEl).setName(name).setDesc(desc);
    if (isPassword) {
      setting.addText((text) => {
        const textEl = text.setPlaceholder(placeholder).setValue(value).onChange(onChange);
        if (textEl.inputEl) {
          textEl.inputEl.type = "password";
        }
        return textEl;
      });
    } else {
      setting.addText((text) => text.setPlaceholder(placeholder).setValue(value).onChange(onChange));
    }
  }
  /**
   * 폴더 매핑을 화면에 표시합니다
   */
  displayFolderMappings() {
    this.folderMapContainer.empty();
    this.plugin.settings.folderMappings.forEach((mapping, index) => {
      const mappingEl = this.folderMapContainer.createDiv("folder-mapping");
      mappingEl.createEl("h4", { text: `Folder Mapping #${index + 1}` });
      new import_obsidian.Setting(mappingEl).setName("Folder Path").setDesc("Path to the folder (e.g.: folder/subfolder)").addText((text) => text.setValue(mapping.folderPath).onChange(async (value) => {
        this.plugin.settings.folderMappings[index].folderPath = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(mappingEl).setName("Domain Name").addText((text) => text.setPlaceholder("my-domain").setValue(mapping.domainName).onChange(async (value) => {
        this.plugin.settings.folderMappings[index].domainName = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(mappingEl).setName("Channel Hash").addText((text) => text.setPlaceholder("channel-hash").setValue(mapping.channelHash).onChange(async (value) => {
        this.plugin.settings.folderMappings[index].channelHash = value;
        await this.plugin.saveSettings();
      }));
      new import_obsidian.Setting(mappingEl).setName("Token Key").addText((text) => {
        const textEl = text.setPlaceholder("your-token-key").setValue(mapping.tokenKey).onChange(async (value) => {
          this.plugin.settings.folderMappings[index].tokenKey = value;
          await this.plugin.saveSettings();
        });
        if (textEl.inputEl) {
          textEl.inputEl.type = "password";
        }
        return textEl;
      });
      new import_obsidian.Setting(mappingEl).addButton((button) => button.setButtonText("Delete").setWarning().onClick(async () => {
        this.plugin.settings.folderMappings.splice(index, 1);
        await this.plugin.saveSettings();
        this.displayFolderMappings();
      }));
    });
  }
};
